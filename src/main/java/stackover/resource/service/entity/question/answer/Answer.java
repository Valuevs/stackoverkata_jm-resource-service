package stackover.resource.service.entity.question.answer;import jakarta.persistence.CascadeType;import jakarta.persistence.Column;import jakarta.persistence.Convert;import jakarta.persistence.Entity;import jakarta.persistence.EntityNotFoundException;import jakarta.persistence.FetchType;import jakarta.persistence.GeneratedValue;import jakarta.persistence.Id;import jakarta.persistence.JoinColumn;import jakarta.persistence.Lob;import jakarta.persistence.ManyToOne;import jakarta.persistence.OneToMany;import jakarta.persistence.PrePersist;import jakarta.persistence.PreUpdate;import jakarta.persistence.Table;import jakarta.validation.constraints.NotNull;import lombok.AllArgsConstructor;import lombok.Getter;import lombok.NoArgsConstructor;import lombok.Setter;import org.hibernate.annotations.CreationTimestamp;import org.hibernate.annotations.JdbcTypeCode;import org.hibernate.annotations.UpdateTimestamp;import stackover.resource.service.converters.LocalDateTimeConverter;import stackover.resource.service.entity.question.Question;import stackover.resource.service.entity.user.User;import java.sql.Types;import java.time.LocalDateTime;import java.util.ArrayList;import java.util.List;import java.util.Objects;@Entity@Getter@Setter@NoArgsConstructor@AllArgsConstructor@Table(name = "answer")public class Answer {    @Id    @GeneratedValue(generator = "ID_GENERATOR_POOLED")    private Long id;    @CreationTimestamp    @Column(name = "persist_date", updatable = false)    @JdbcTypeCode(Types.LONGVARCHAR)    @Convert(converter = LocalDateTimeConverter.class)    private LocalDateTime persistDateTime;    @Column(name = "update_date", nullable = false)    @UpdateTimestamp    private LocalDateTime updateDateTime;    @ManyToOne(fetch = FetchType.LAZY, optional = false)    @JoinColumn(name = "question_id")    private Question question;    @ManyToOne(fetch = FetchType.LAZY, optional = false)    @JoinColumn(name = "account_id")    private User user;    @Lob    @NotNull    @Column    @JdbcTypeCode(Types.LONGVARCHAR)    private String htmlBody;    @NotNull    @Column(name = "is_helpful")    private Boolean isHelpful;    @NotNull    @Column(name = "is_deleted")    private Boolean isDeleted;    @NotNull    @Column(name = "is_deleted_by_moderator")    private Boolean isDeletedByModerator;    @Column(name = "date_accept_time")    private LocalDateTime dateAcceptTime;    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY, mappedBy = "answer", orphanRemoval = true)    private List<CommentAnswer> commentAnswers = new ArrayList<>();    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY, mappedBy = "answer", orphanRemoval = true)    private List<VoteAnswer> voteAnswers = new ArrayList<>();    @PrePersist    private void prePersistFunction() {        checkConstraints();    }    @PreUpdate    private void preUpdateFunction() {        checkConstraints();    }    private void checkConstraints() {        try {            if (this.user.getId() <= 0) {                throw new EntityNotFoundException("User id must be > 0 on create or update.");            }        } catch (NullPointerException e) {            throw new EntityNotFoundException("User id must be not null on create.");        }    }    @Override    public boolean equals(Object o) {        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        Answer answer = (Answer) o;        return Objects.equals(id, answer.id) &&                Objects.equals(persistDateTime, answer.persistDateTime) &&                Objects.equals(updateDateTime, answer.updateDateTime) &&                Objects.equals(question, answer.question) &&                Objects.equals(user, answer.user) &&                Objects.equals(htmlBody, answer.htmlBody) &&                Objects.equals(isHelpful, answer.isHelpful) &&                Objects.equals(isDeleted, answer.isDeleted) &&                Objects.equals(isDeletedByModerator, answer.isDeletedByModerator) &&                Objects.equals(dateAcceptTime, answer.dateAcceptTime);    }    @Override    public int hashCode() {        return Objects.hash(id, persistDateTime, updateDateTime, question, user, htmlBody, isHelpful, isDeleted, isDeletedByModerator, dateAcceptTime);    }}